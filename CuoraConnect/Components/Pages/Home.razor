@page "/"
@using System.ComponentModel.DataAnnotations;
@using System.Diagnostics;
@using System.Net.Http.Headers;
@using System.IO;
@using System.Net.Http;
@using System.Threading.Tasks;
@using System.Xml.Linq;
@using Microsoft.Maui.Controls;
@using System.Net;
@using System.Text;
@using System.Reflection;
@using System.Security.Cryptography;

<h3>Configuração de Rede Wi-Fi</h3>

<EditForm Model="@wifiConfig" OnValidSubmit="SubmitForm">
    <DataAnnotationsValidator />

    <div class="form-group">
        <label for="ssid">SSID (Nome da Rede)</label>
        <InputText id="ssid" class="form-control" @bind-Value="wifiConfig.SSID" />
        <ValidationMessage For="@(() => wifiConfig.SSID)" />
    </div>

    <div class="form-group">
        <label for="password">Senha</label>
        <InputText id="password" class="form-control" type="password" @bind-Value="wifiConfig.Password" />
        <ValidationMessage For="@(() => wifiConfig.Password)" />
    </div>

    <div class="form-group">
        <label for="encryption">Tipo de Criptografia</label>
        <InputSelect id="encryption" class="form-control" @bind-Value="wifiConfig.Encryption">
            <option value="WPA2" selected>WPA2</option>
            <option value="WPA3">WPA3</option>
            <option value="WEP">WEP</option>
            <option value="None">Nenhuma</option>
        </InputSelect>
        <ValidationMessage For="@(() => wifiConfig.Encryption)" />
    </div>

    <div class="form-group">
        <label for="ip">Endereço IP</label>
        <InputText id="ip" class="form-control" @bind-Value="wifiConfig.IpAddress" />
        <ValidationMessage For="@(() => wifiConfig.IpAddress)" />
    </div>

    <div class="form-group">
        <label for="gateway">Gateway Padrão</label>
        <InputText id="gateway" class="form-control" @bind-Value="wifiConfig.Gateway" />
        <ValidationMessage For="@(() => wifiConfig.Gateway)" />
    </div>

    <div class="form-group">
        <label for="primaryDns">DNS Primário</label>
        <InputText id="primaryDns" class="form-control" @bind-Value="wifiConfig.PrimaryDns" />
        <ValidationMessage For="@(() => wifiConfig.PrimaryDns)" />
    </div>

    <div class="form-group">
        <label for="secondaryDns">DNS Secundário</label>
        <InputText id="secondaryDns" class="form-control" @bind-Value="wifiConfig.SecondaryDns" />
        <ValidationMessage For="@(() => wifiConfig.SecondaryDns)" />
    </div>

    <button type="submit" style="margin-top:10px;" class="btn btn-primary">Salvar Configurações</button>
</EditForm>

@if (showErrorMessage)
{
    <div class="alert alert-danger" style="margin-top: 10px;">
        Verifique a conexão do Wi-Fi da Cuora Max ou desabilite sua conexão com os dados móveis.
    </div>
}

@code {
    private WifiConfigModel wifiConfig = new WifiConfigModel();
    private bool showErrorMessage = false;

    private async void SubmitForm()
    {
      await  CopyEmbeddedFileToLocalStorageAsync();
        var client = new HttpClient();

    // Credenciais de autenticação
    string username = "admin";
    string password = "admin";

    // URL do servidor Flask
    string url = "http://127.0.0.1:5000/import/config";

        string filePath;
    // Nome do arquivo local que você deseja enviar
        if (OperatingSystem.IsWindows())
        {
            filePath = "C:\\Users\\Systel\\Downloads\\Suporte Max e Qendra\\Scripts configuracion WiFi MAX- V3 para Rev E13\\Config extraido\\config_default.xml";
        }
        else if (DeviceInfo.Platform == DevicePlatform.Android)
        {
            filePath = Path.Combine(FileSystem.AppDataDirectory, "config_default.xml");
        }
        else
        {
            Debug.WriteLine("Plataforma não suportada");
            return; // Saia do método se a plataforma não for suportada
        }

        if (string.IsNullOrEmpty(filePath))
        {
            Debug.WriteLine("Erro: O caminho do arquivo não foi definido.");
            return; // Saia do método se filePath não estiver definido
        }

    try
    {
        using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);
        using var content = new MultipartFormDataContent();
        using var fileContent = new StreamContent(fileStream);

        // Adiciona o arquivo no conteúdo do formulário
        content.Add(fileContent, "configrecord", Path.GetFileName(filePath));

        // Realiza uma requisição inicial para obter os cabeçalhos de autenticação
        var initialResponse = await client.GetAsync(url);
        if (initialResponse.Headers.WwwAuthenticate.ToString().StartsWith("Digest"))
        {
            // Processa o cabeçalho WWW-Authenticate
            var authHeader = initialResponse.Headers.WwwAuthenticate.ToString();
            var authResponse = CreateDigestHeader(authHeader, username, password, "POST", url);

            // Adiciona o cabeçalho de autenticação Digest
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Digest", authResponse);

            // Faz o upload do arquivo
            var response = await client.PostAsync(url, content);
            response.EnsureSuccessStatusCode();

            var responseBody = await response.Content.ReadAsStringAsync();
            Debug.WriteLine($"Resposta do servidor: {responseBody}");
        }
    }
    catch (Exception ex)
    {
        Debug.WriteLine($"Erro ao enviar arquivo: {ex.Message}");
    }
}

// Método para gerar o cabeçalho de autenticação Digest
private string CreateDigestHeader(string authHeader, string username, string password, string method, string url)
{
    var digestValues = ParseDigestHeader(authHeader);

    string ha1 = ComputeMD5Hash($"{username}:{digestValues["realm"]}:{password}");
    string ha2 = ComputeMD5Hash($"{method}:{url}");
    string response = ComputeMD5Hash($"{ha1}:{digestValues["nonce"]}:{digestValues["nc"]}:{digestValues["cnonce"]}:{digestValues["qop"]}:{ha2}");

    return $"username=\"{username}\", realm=\"{digestValues["realm"]}\", nonce=\"{digestValues["nonce"]}\", uri=\"{url}\", qop={digestValues["qop"]}, nc={digestValues["nc"]}, cnonce=\"{digestValues["cnonce"]}\", response=\"{response}\", opaque=\"{digestValues["opaque"]}\"";
}

// Método para calcular o hash MD5
private string ComputeMD5Hash(string input)
{
    using var md5 = MD5.Create();
    byte[] inputBytes = Encoding.ASCII.GetBytes(input);
    byte[] hashBytes = md5.ComputeHash(inputBytes);
    return BitConverter.ToString(hashBytes).Replace("-", "").ToLower();
}

// Método para analisar o cabeçalho Digest WWW-Authenticate
private Dictionary<string, string> ParseDigestHeader(string header)
{
    var values = new Dictionary<string, string>();
    var parts = header.Replace("Digest ", "").Split(',');

    foreach (var part in parts)
    {
        var kv = part.Trim().Split('=');
        values[kv[0]] = kv[1].Replace("\"", "");
    }

    // Valores adicionais que podem ser necessários
    values["nc"] = "00000001";
    values["cnonce"] = Guid.NewGuid().ToString("N").Substring(0, 8);

    return values;

    }

    private string ExtractValueFromXml(string filePath, string itemName)
    {
        try
        {
            XDocument doc = XDocument.Load(filePath);
            var valueElement = doc.Descendants("configitem")
                .FirstOrDefault(x => (string)x.Attribute("name") == itemName)
                ?.Element("value");

            return valueElement != null ? valueElement.Value : string.Empty;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Erro ao ler o arquivo XML: {ex.Message}");
            return string.Empty;
        }
    }

    public class WifiConfigModel
    {
        [Required(ErrorMessage = "O SSID é obrigatório")]
        public string SSID { get; set; }

        [Required(ErrorMessage = "A senha é obrigatória")]
        public string Password { get; set; }

        public string Encryption { get; set; }

        [Required(ErrorMessage = "O endereço IP é obrigatório")]
        [RegularExpression(@"^(\d{1,3}\.){3}\d{1,3}$", ErrorMessage = "Endereço IP inválido")]
        public string IpAddress { get; set; }

        [Required(ErrorMessage = "O gateway é obrigatório")]
        [RegularExpression(@"^(\d{1,3}\.){3}\d{1,3}$", ErrorMessage = "Gateway inválido")]
        public string Gateway { get; set; }

        [Required(ErrorMessage = "O DNS primário é obrigatório")]
        [RegularExpression(@"^(\d{1,3}\.){3}\d{1,3}$", ErrorMessage = "DNS primário inválido")]
        public string PrimaryDns { get; set; }

        [Required(ErrorMessage = "O DNS secundário é obrigatório")]
        [RegularExpression(@"^(\d{1,3}\.){3}\d{1,3}$", ErrorMessage = "DNS secundário inválido")]
        public string SecondaryDns { get; set; }
    }
    public async Task CopyEmbeddedFileToLocalStorageAsync()
    {
        // Nome do arquivo XML
        string fileName = "config_default.xml";

        // Caminho onde o arquivo será salvo no armazenamento local (pasta files)
        string destinationPath = Path.Combine(FileSystem.AppDataDirectory, fileName);

        // Verifica se o arquivo já existe na pasta files, para evitar sobrescrever
        if (File.Exists(destinationPath))
        {
            Debug.WriteLine($"{fileName} já existe na pasta de destino.");
            return;
        }

        try
        {
            // Acessa o arquivo como recurso MauiAsset
            using Stream fileStream = await FileSystem.OpenAppPackageFileAsync(fileName);

            // Cria o arquivo no diretório de destino
            using FileStream destFileStream = File.Create(destinationPath);

            // Copia o conteúdo do arquivo embutido para o armazenamento local
            await fileStream.CopyToAsync(destFileStream);

            Debug.WriteLine($"Arquivo {fileName} copiado para {destinationPath}");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Erro ao copiar o arquivo: {ex.Message}");
        }
    }
}
